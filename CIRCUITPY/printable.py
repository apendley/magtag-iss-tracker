# Here we're taking advantage of the MagTag/ESP32-S2's massive 2MB PSRAM to store some metadata about our fonts.
# The main services provided here are to determine if a given unicode code point is
# renderable by our fonts, and if not, provide some very basic transliteration from unrecognized
# characters into (hopefully) reasonable ASCII substitutes.

# First, the code point mapping for our fonts. Lucky for us, all of our fonts (except the numeric-only font) 
# provide the same set of glyphs, so we don't need to generate a separate set for each font.
# BUT...I had to split this up into multiple sets, because I was exhausting the pystack 
# parsing this file when it was a single set.
_valid_code_points_1 = {
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x00A0,
    0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AE, 0x00AF, 0x00B0, 0x00B1,
    0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, 0x00C0, 0x00C1, 
    0x00C2,0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, 0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, 0x00D0, 0x00D1, 
    0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, 0x00E0, 0x00E1, 
    0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, 0x00F0, 0x00F1, 
    0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, 0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, 0x0100, 0x0101, 
    0x0102, 0x0103, 0x0104, 0x0105, 0x0106, 0x0107, 0x0108, 0x0109, 0x010A, 0x010B, 0x010C, 0x010D, 0x010E, 0x010F, 0x0110, 0x0111, 
    0x0112, 0x0113, 0x0114, 0x0115, 0x0116, 0x0117, 0x0118, 0x0119, 0x011A, 0x011B, 0x011C, 0x011D, 0x011E, 0x011F, 0x0120, 0x0121, 
    0x0122, 0x0123,
}

_valid_code_points_2 = {
    0x0124, 0x0125, 0x0126, 0x0127, 0x0128, 0x0129, 0x012A, 0x012B, 0x012C, 0x012D, 0x012E, 0x012F, 0x0130, 0x0131, 0x0132, 0x0133,
    0x0134, 0x0135, 0x0136, 0x0137, 0x0138, 0x0139, 0x013A, 0x013B, 0x013C, 0x013D, 0x013E, 0x013F, 0x0140, 0x0141, 0x0142, 0x0143,
    0x0144, 0x0145, 0x0146, 0x0147, 0x0148, 0x014A, 0x014B, 0x014C, 0x014D, 0x014E, 0x014F, 0x0150, 0x0151, 0x0152, 0x0153, 0x0154,
    0x0155, 0x0156, 0x0157, 0x0158, 0x0159, 0x015A, 0x015B, 0x015C, 0x015D, 0x015E, 0x015F, 0x0160, 0x0161, 0x0162, 0x0163, 0x0164,
    0x0165, 0x0166, 0x0167, 0x0168, 0x0169, 0x016A, 0x016B, 0x016C, 0x016D, 0x016E, 0x016F, 0x0170, 0x0171, 0x0172, 0x0173, 0x0174,
    0x0175, 0x0176, 0x0177, 0x0178, 0x0179, 0x017A, 0x017B, 0x017C, 0x017D, 0x017E, 0x018F, 0x0192, 0x01E2, 0x01E3, 0x01FA, 0x01FB,
    0x01FC, 0x01FD, 0x01FE, 0x01FF, 0x0218, 0x0219, 0x021A, 0x021B, 0x0226, 0x0227, 0x0232, 0x0233, 0x0237, 0x0259, 0x02C6, 0x02C7,
    0x02D8, 0x02D9, 0x02DA, 0x02DB, 0x02DC, 0x02DD, 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0306, 0x0307, 0x0308, 0x030A, 0x030B,
    0x030C, 0x0312, 0x0323, 0x0326, 0x0327, 0x0328, 0x0E3F, 0x1E80, 0x1E81, 0x1E82, 0x1E83, 0x1E84, 0x1E85, 0x1E9E, 0x1EA0, 0x1EA1,
    0x1EB8, 0x1EB9, 0x1EBC, 0x1EBD, 0x1ECA, 0x1ECB, 0x1ECC, 0x1ECD, 0x1EE4, 0x1EE5, 0x1EF2, 0x1EF3, 0x1EF8, 0x1EF9, 0x2013, 0x2014,
    0x2018, 0x2019, 0x201A, 0x201C, 0x201D, 0x201E, 0x2020, 0x2021, 0x2022, 0x2026, 0x2030, 0x2039, 0x203A, 0x2044, 0x2070, 0x2074,
    0x2075, 0x2076, 0x2077, 0x2078, 0x2079, 0x2080, 0x2081, 0x2082, 0x2083, 0x2084, 0x2085, 0x2086, 0x2087, 0x2088, 0x2089, 0x20AC,
    0x20B9, 0x20BA, 0x20BD, 0x20BF, 0x2122, 0x215B, 0x215C, 0x215D, 0x215E, 0x2190, 0x2191, 0x2192, 0x2193, 0x2196, 0x2197, 0x2198,
    0x2199, 0x2202, 0x2206, 0x220F, 0x2211, 0x2212, 0x221A, 0x221E, 0x222B, 0x2248, 0x2260, 0x2264, 0x2265, 0x25CA, 0xFB01, 0xFB02,
}

_valid_code_point_sets = (
    _valid_code_points_1,
    _valid_code_points_2,
)

# Second, the mapping from unicode code points to ascii substitutes.
# Fair warning: I used ChatGPT to help generate this map, and I have not double-checked every single mapping.
# I am 0% vouching for its accuracy, and if you use it, you do so at your own risk.
# Corrections by speakers of any of the included languages are welcome.
_unicode_to_ascii_map = {
    # Latin characters with acute, grave, circumflex, tilde, umlaut, and other common accents
    0x00C0: 'A',  # À
    0x00C1: 'A',  # Á
    0x00C2: 'A',  # Â
    0x00C3: 'A',  # Ã
    0x00C4: 'A',  # Ä
    0x00C5: 'A',  # Å
    0x00C6: 'AE', # Æ
    0x00C7: 'C',  # Ç
    0x00C8: 'E',  # È
    0x00C9: 'E',  # É
    0x00CA: 'E',  # Ê
    0x00CB: 'E',  # Ë
    0x00CC: 'I',  # Ì
    0x00CD: 'I',  # Í
    0x00CE: 'I',  # Î
    0x00CF: 'I',  # Ï
    0x00D1: 'N',  # Ñ
    0x00D2: 'O',  # Ò
    0x00D3: 'O',  # Ó
    0x00D4: 'O',  # Ô
    0x00D5: 'O',  # Õ
    0x00D6: 'O',  # Ö
    0x00D8: 'O',  # Ø
    0x00D9: 'U',  # Ù
    0x00DA: 'U',  # Ú
    0x00DB: 'U',  # Û
    0x00DC: 'U',  # Ü
    0x00DD: 'Y',  # Ý
    0x0152: 'OE', # Œ
    0x00DF: 'ss', # ß
    0x00E0: 'a',  # à
    0x00E1: 'a',  # á
    0x00E2: 'a',  # â
    0x00E3: 'a',  # ã
    0x00E4: 'a',  # ä
    0x00E5: 'a',  # å
    0x00E6: 'ae', # æ
    0x00E7: 'c',  # ç
    0x00E8: 'e',  # è
    0x00E9: 'e',  # é
    0x00EA: 'e',  # ê
    0x00EB: 'e',  # ë
    0x00EC: 'i',  # ì
    0x00ED: 'i',  # í
    0x00EE: 'i',  # î
    0x00EF: 'i',  # ï
    0x00F1: 'n',  # ñ
    0x00F2: 'o',  # ò
    0x00F3: 'o',  # ó
    0x00F4: 'o',  # ô
    0x00F5: 'o',  # õ
    0x00F6: 'o',  # ö
    0x00F8: 'o',  # ø
    0x00F9: 'u',  # ù
    0x00FA: 'u',  # ú
    0x00FB: 'u',  # û
    0x00FC: 'u',  # ü
    0x00FD: 'y',  # ý
    0x00FF: 'y',  # ÿ

    # Characters with macron, caron, and other diacritic marks
    0x0100: 'A',  # Ā
    0x0102: 'A',  # Ă
    0x0104: 'A',  # Ą
    0x0112: 'E',  # Ē
    0x0114: 'E',  # Ĕ
    0x0116: 'E',  # Ė
    0x0118: 'E',  # Ę
    0x011A: 'E',  # Ě
    0x012A: 'I',  # Ī
    0x012C: 'I',  # Ĭ
    0x012E: 'I',  # Į
    0x0130: 'I',  # İ
    0x014C: 'O',  # Ō
    0x014E: 'O',  # Ŏ
    0x0150: 'O',  # Ő
    0x016A: 'U',  # Ū
    0x016C: 'U',  # Ŭ
    0x016E: 'U',  # Ů
    0x0170: 'U',  # Ű
    0x0172: 'U',  # Ų
    0x0176: 'Y',  # Ŷ
    0x0179: 'Z',  # Ź
    0x017B: 'Z',  # Ż
    0x017D: 'Z',  # Ž

    # Ligatures used in various languages (common in French, German, Danish, etc.)
    0x0152: 'OE', # Œ
    0x00E6: 'ae', # æ

    # Characters used in Scandinavian languages (e.g., Danish, Norwegian, Swedish)
    0x00C5: 'A',  # Å
    0x00E5: 'a',  # å
    0x00D8: 'O',  # Ø
    0x00F8: 'o',  # ø
    0x00C4: 'A',  # Ä
    0x00E4: 'a',  # ä
    0x00D6: 'O',  # Ö
    0x00F6: 'o',  # ö

    # Characters used in Eastern European and Slavic languages (e.g., Czech, Slovak, Polish)
    0x010C: 'C',  # Č
    0x0107: 'c',  # č
    0x010E: 'D',  # Ď
    0x0111: 'd',  # ď
    0x011A: 'E',  # Ė
    0x011B: 'e',  # ė
    0x0158: 'R',  # Ř
    0x0159: 'r',  # ř
    0x0160: 'S',  # Š
    0x0161: 's',  # š
    0x017D: 'Z',  # Ž
    0x017E: 'z',  # ž
    0x0141: 'L',  # Ł
    0x0142: 'l',  # ł

    # Characters from the Baltic languages (e.g., Latvian, Lithuanian)
    0x0112: 'E',  # Ē
    0x0113: 'e',  # ē
    0x0136: 'K',  # Ķ
    0x0137: 'k',  # ķ
    0x0139: 'L',  # Ĺ
    0x013A: 'l',  # ĺ
    0x014C: 'O',  # Ō
    0x014D: 'o',  # ō

    # Characters used in Romanian (e.g., Ș, Ț) and some other regional variations
    0x0218: 'S',  # Ș
    0x0219: 's',  # ș
    0x021A: 'T',  # Ţ
    0x021B: 't',  # ţ

    # Characters used in Turkish (e.g., İ, ı, Ğ, Ş)
    0x0130: 'I',  # İ
    0x0131: 'i',  # ı
    0x011E: 'G',  # Ğ
    0x011F: 'g',  # ğ
    0x015E: 'S',  # Ş
    0x015F: 's',  # ş

    # Iberian Peninsula (Spanish, Portuguese)
    0x00D1: 'N',  # Ñ
    0x00F1: 'n',  # ñ
    0x00C7: 'C',  # Ç
    0x00E7: 'c',  # ç

    # Special characters for Eastern European languages (Hungarian, Ukrainian, etc.)
    0x0150: 'O',  # Ő
    0x0151: 'o',  # ő
    0x0170: 'U',  # Ű
    0x0171: 'u',  # ű

    # Characters from French, Italian, and other Romance languages (é, è, ç)
    0x00E9: 'e',  # é
    0x00E8: 'e',  # è
    0x00EA: 'e',  # ê
    0x00EB: 'e',  # ë
    0x00E7: 'c',  # ç
    
    # Miscellaneous European characters
    0x011E: 'G',  # Ğ
    0x011F: 'g',  # ğ
    0x0130: 'I',  # İ
    0x0131: 'i',  # ı
    0x015E: 'S',  # Ş
    0x015F: 's',  # ş

    # Greek letters (converted to closest Latin equivalent for display)
    0x03B1: 'a',  # α
    0x03B2: 'b',  # β
    0x03B3: 'g',  # γ
    0x03B4: 'd',  # δ
    0x03B5: 'e',  # ε
    0x03B6: 'z',  # ζ
    0x03B7: 'h',  # η
    0x03B8: 'th', # θ
    0x03B9: 'i',  # ι
    0x03BA: 'k',  # κ
    0x03BB: 'l',  # λ
    0x03BC: 'm',  # μ
    0x03BD: 'n',  # ν
    0x03BE: 'x',  #,

    # Uppercase Cyrillic
    0x0410: "A",   # А -> A
    0x0411: "B",   # Б -> B
    0x0412: "V",   # В -> V
    0x0413: "G",   # Г -> G
    0x0414: "D",   # Д -> D
    0x0415: "E",   # Е -> E
    0x0401: "Yo",  # Ё -> Yo (or just E)
    0x0416: "Zh",  # Ж -> Zh
    0x0417: "Z",   # З -> Z
    0x0418: "I",   # И -> I
    0x0419: "J",   # Й -> J (or I)
    0x041A: "K",   # К -> K
    0x041B: "L",   # Л -> L
    0x041C: "M",   # М -> M
    0x041D: "N",   # Н -> N
    0x041E: "O",   # О -> O
    0x041F: "P",   # П -> P
    0x0420: "R",   # Р -> R
    0x0421: "S",   # С -> S
    0x0422: "T",   # Т -> T
    0x0423: "U",   # У -> U
    0x0424: "F",   # Ф -> F
    0x0425: "H",   # Х -> H
    0x0426: "C",   # Ц -> C
    0x0427: "Ch",  # Ч -> Ch
    0x0428: "Sh",  # Ш -> Sh
    0x0429: "Shch",# Щ -> Shch
    0x042B: "Y",   # Ы -> Y
    0x042C: "E",   # Э -> E
    0x042E: "Yu",  # Ю -> Yu
    0x042F: "Ya",  # Я -> Ya

    # Lowercase Cyrillic
    0x0430: "a",   # а -> a
    0x0431: "b",   # б -> b
    0x0432: "v",   # в -> v
    0x0433: "g",   # г -> g
    0x0434: "d",   # д -> d
    0x0435: "e",   # е -> e
    0x0451: "yo",  # ё -> yo
    0x0436: "zh",  # ж -> zh
    0x0437: "z",   # з -> z
    0x0438: "i",   # и -> i
    0x0439: "j",   # й -> j (or i)
    0x043A: "k",   # к -> k
    0x043B: "l",   # л -> l
    0x043C: "m",   # м -> m
    0x043D: "n",   # н -> n
    0x043E: "o",   # о -> o
    0x043F: "p",   # п -> p
    0x0440: "r",   # р -> r
    0x0441: "s",   # с -> s
    0x0442: "t",   # т -> t
    0x0443: "u",   # у -> u
    0x0444: "f",   # ф -> f
    0x0445: "h",   # х -> h
    0x0446: "c",   # ц -> c
    0x0447: "ch",  # ч -> ch
    0x0448: "sh",  # ш -> sh
    0x0449: "shch",# щ -> shch
    0x044B: "y",   # ы -> y
    0x044C: "e",   # э -> e
    0x044E: "yu",  # ю -> yu
    0x044F: "ya",  # я -> ya

    # Special characters
    0x0454: "u",   # є -> u
    0x0456: "i",   # і -> i
    0x0457: "yi",  # ї -> yi
    0x0458: "j",   # ј -> j
    0x045A: "l",   # љ -> l
    0x045C: "nj",  # њ -> nj
    0x045E: "ts",  # тс (non-standard)
    0x0460: "s",   # ш -> s
    0x0462: "s",   # шч

    # Arabic
    0x0621: "'",   # ء -> '
    0x0622: "A",   # آ -> A
    0x0623: "A",   # أ -> A
    0x0624: "A",   # إ -> A
    0x0625: "E",   # ة -> E
    0x0626: "E",   # ة -> E
    0x0627: "A",   # ا -> A
    0x0628: "b",   # ب -> b
    0x0629: "t",   # ت -> t
    0x062A: "t",   # ت -> t
    0x062B: "th",  # ث -> th
    0x062C: "j",   # ج -> j
    0x062D: "h",   # ح -> h
    0x062E: "kh",  # خ -> kh
    0x062F: "d",   # د -> d
    0x0630: "dh",  # ذ -> dh
    0x0631: "r",   # ر -> r
    0x0632: "z",   # ز -> z
    0x0633: "s",   # س -> s
    0x0634: "sh",  # ش -> sh
    0x0635: "s",   # ص -> s
    0x0636: "sh",  # ض -> sh
    0x0637: "s",   # ط -> t
    0x0638: "th",  # ظ -> th
    0x0639: "a",   # ع -> a
    0x063A: "gh",  # غ -> gh
    0x063B: "f",   # ف -> f
    0x063C: "q",   # ق -> q
    0x063D: "k",   # ك -> k
    0x063E: "l",   # ل -> l
    0x063F: "m",   # م -> m
    0x0640: "n",   # ن -> n
    0x0641: "f",   # ف -> f
    0x0642: "q",   # ق -> q
    0x0643: "k",   # ك -> k
    0x0644: "l",   # ل -> l
    0x0645: "m",   # م -> m
    0x0646: "n",   # ن -> n
    0x0647: "h",   # ه -> h
    0x0648: "w",   # و -> w
    0x0649: "y",   # ى -> y
    0x064A: "y",   # ي -> y    

    # Farsi
    0x067E: "p",   # پ -> p
    0x0686: "ch",  # چ -> ch
    0x0698: "zh",  # ژ -> zh
    0x06A9: "k",   # ک -> k
    0x06AF: "g",   # گ -> g

    # Hebrew
    0x05D0: "A",   # א -> A
    0x05D1: "B",   # ב -> B
    0x05D2: "G",   # ג -> G
    0x05D3: "D",   # ד -> D
    0x05D4: "H",   # ה -> H
    0x05D5: "V",   # ו -> V
    0x05D6: "Z",   # ז -> Z
    0x05D7: "Ch",  # ח -> Ch
    0x05D8: "T",   # ט -> T
    0x05D9: "Y",   # י -> Y
    0x05DA: "K",   # כ -> K
    0x05DB: "L",   # ל -> L
    0x05DC: "M",   # מ -> M
    0x05DD: "N",   # נ -> N
    0x05DE: "S",   # ס -> S
    0x05DF: "E",   # ע -> E
    0x05E0: "P",   # פ -> P
    0x05E1: "Ts",  # צ -> Ts
    0x05E2: "Q",   # ק -> Q
    0x05E3: "R",   # ר -> R
    0x05E4: "Sh",  # ש -> Sh
    0x05E5: "T",   # ת -> T    
}

# Convert non-printable characters into printable characters.
# If substitute_ascii is True, an attempt will be made
# to transliterate unrecognized characters into ASCII substitutes.
def make_printable(input_string, substitute_ascii=True):
    validated_string = ""

    for char in input_string:
        printable = get_printable_character(char, substitute_ascii)

        if printable is not None:
            validated_string += printable
        else:
            validated_string += '?'

    return validated_string

# Given a character, determine if it can be printed by our fonts.
# If substitute_ascii is True, an attempt will be made
# to transliterate unrecognized characters into ASCII substitutes.
# If no printable character can be found, return None.
# Otherwise, return the printable character.
def get_printable_character(char, substitute_ascii):
    code_point = ord(char)

    # First, check to see if the code point is supported by the font.
    for code_point_set in _valid_code_point_sets:
        if code_point in code_point_set:
            return char

    # If not, and if specified, attempt to substitute the
    # code points not in the font with "reduced" ascii equivalents.
    if substitute_ascii and (code_point in _unicode_to_ascii_map):
        return _unicode_to_ascii_map[code_point]
    
    # Give up and let the caller decide how to handle the character.
    return None